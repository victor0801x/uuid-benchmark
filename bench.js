'use strict'

const fs = require('fs')
const {Suite} = require('benchmark')
const toCsv = require('csv-stringify')
const table = require('markdown-table')
const numeral = require('numeral')

const suite = new Suite()

suite.cacheSizes = [16 ** 2, 16 ** 3, 16 ** 4]

const origAdd = suite.add
suite.add = function (...args) {
  // setup default property values on the Benchmark object
  // TODO: This will not work if there's no options object
  for (let i = 0; i < 3; i++) {
    if (typeof args[i] === 'object') {
      args[i] = Object.assign({
        guid: true,
        leaky: false,
        random: true,
        reuse: false
      }, args[i])
      break
    }
  }
  return origAdd.apply(this, args)
}

const single = process.argv[2]

if (single) {
  require(single)(suite)
} else {
  // uuid
  require('./benchmarks/uuid')(suite)
  require('./benchmarks/fast-uuid')(suite)
  require('./benchmarks/uuid-random')(suite)
  require('./benchmarks/sodium-uuid')(suite)
  require('./benchmarks/sodium-native')(suite)
  require('./benchmarks/crypto.randomBytes')(suite)
  require('./benchmarks/crypto.randomFillSync')(suite)
  require('./benchmarks/crypto.randomFill')(suite)
  require('./benchmarks/dev-random')(suite)
  require('./benchmarks/uuid-1345')(suite)

  // other
  require('./benchmarks/hyperid')(suite)
  require('./benchmarks/cuid')(suite)
  require('./benchmarks/shortid')(suite)
  require('./benchmarks/nanoid')(suite)
}

suite
  .on('cycle', function (event) {
    const t = event.target
    console.log(`${desc(t)} x ${numeral(t.hz).format('0,0')} ops/sec ¬±${t.stats.rme.toFixed(2)}% (${t.stats.sample.length} runs sampled)`)
  })
  .on('complete', function () {
    console.log('Fastest is ' + desc(this.filter('fastest')[0]))

    // if running just a single benchmark, skip updating result files
    if (!single) {
      updateReadme()
      updateCsv()
    }
  })
  .run()

function updateReadme () {
  const path = 'README.md'
  const marker = '<!-- AUTOGENERATED - DO NOT EDIT -->\n'
  const parts = fs.readFileSync(path, 'utf8').split(marker)
  parts[1] = uuidTable()
  parts[3] = otherTable()
  fs.writeFileSync(path, parts.join(marker))
}

function updateCsv () {
  csv(function (err, output) {
    if (err) throw err
    fs.writeFileSync('results.csv', output)
  })
}

function uuidTable () {
  const arr = suite.filter(function (b) {
    return b.format !== 'other'
  }).map(function (b) {
    return [
      method(b),
      features(b),
      check(b.reuse),
      check(!b.defer),
      b.cacheSize || '',
      b.format,
      numeral(b.hz).format('0,0'),
      `¬±${b.stats.rme.toFixed(2)}%`,
      b.stats.sample.length
    ]
  })

  arr.unshift([
    'Method',
    'Features',
    'Re-use',
    'Sync',
    'Cache',
    'Format',
    'Ops/sec',
    'RME',
    'Samples'
  ])

  return table(arr, {align: ['l', 'l', 'c', 'c', 'r', 'l', 'r', 'l', 'r']}) + '\n'
}

function otherTable () {
  const arr = suite.filter(function (b) {
    return b.format === 'other'
  }).map(function (b) {
    return [
      method(b),
      features(b),
      check(b.reuse),
      check(!b.defer),
      b.cacheSize || '',
      numeral(b.hz).format('0,0'),
      `¬±${b.stats.rme.toFixed(2)}%`,
      b.stats.sample.length,
      `<sub><sub>${b.example}</sub></sub>`
    ]
  })

  arr.unshift([
    'Method',
    'Features',
    'Re-use',
    'Sync',
    'Cache',
    'Ops/sec',
    'RME',
    'Samples',
    'Example'
  ])

  return table(arr, {align: ['l', 'l', 'c', 'c', 'r', 'r', 'l', 'r', 'l']}) + '\n'
}

function csv (cb) {
  const arr = suite.map(function (b) {
    return [
      fullName(b),
      b.format !== 'other' || b.guid ? 'Y' : 'N',
      b.leaky ? 'Y' : 'N',
      b.random ? 'Y' : 'N',
      b.reuse ? 'Y' : 'N',
      !b.defer ? 'Y' : 'N',
      b.cacheSize || '',
      b.format,
      b.hz,
      b.stats.deviation,
      b.stats.mean,
      b.stats.moe,
      b.stats.rme,
      b.stats.sample.length,
      b.stats.sem,
      b.stats.variance
    ]
  })

  arr.unshift([
    'Method',
    'GUID',
    'Leaky',
    'Random',
    'Re-use',
    'Sync',
    'Cache',
    'Format',
    'Ops/sec',
    'Deviation',
    'Mean',
    'MOE',
    'RME',
    'Samples',
    'SEM',
    'Variance'
  ])

  toCsv(arr, cb)
}

function fullName (b) {
  return b.name + (b.postfix ? ' ' + b.postfix : '')
}

function desc (b) {
  return `${fullName(b)} (format: ${b.format}, re-use: ${!!b.reuse}, cache: ${b.cacheSize || 'n/a'}, sync: ${!b.defer})`
}

function method (b) {
  return `[${b.name}] ${b.postfix || ''}`
}

function features (b) {
  return guid(b) + random(b) + secure(b)
}

function check (bool) {
  return bool ? '‚úÖ' : ''
}

function guid (b) {
  return b.guid ? 'üåé' : ''
}

function secure (b) {
  return b.leaky ? '' : 'üõ°Ô∏è'
}

function random (b) {
  return b.random ? 'üîÄ' : ''
}
